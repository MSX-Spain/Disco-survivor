001   0000                 output "main.bin"
002   0000             	include "src/vars_msxBios.asm"   
001+  0000             
002+  0000             ;http://map.grauw.nl/resources/msxbios.php
003+  0000             ; use RST assembler mnemonic to call
004+  0000             CHKRAM equ 0x00 ; RST 0x00 > Check RAM and sets slot for command area.
005+  0000             SYNCHR equ 0x08 ; RST	0x08 > Checks if then current character pointed by HL is one desired.
006+  0000             CHRGTR equ 0x10 ; RST	0x10 > Gets the next character (or token) of the Basic-text
007+  0000             OUTDO  equ 0x18 ; RST	0x18 > Output to current outputchannel (printer, diskfile, etc.)
008+  0000             DCOMPR equ 0x20 ; RST	0x20 > Compares HL with DE
009+  0000             GETYPR equ 0x28 ; RST	0x28 > Returns Type of DAC
010+  0000             CALLF  equ 0x30 ; RST	0x30 > Executes an interslot call
011+  0000             KEYINT equ 0x38 ; RST	0x38 > Executes the timer interrupt process routine
012+  0000             
013+  0000             ; use CALL assembler mnemonic
014+  0000             RDSLT  equ 0x000C ; Reads the value of an address in another slot
015+  0000             WRSLT  equ 0x0014 ; Writes a value to an address in another slot
016+  0000             CALSLT equ 0x001C ; Executes inter-slot call
017+  0000             ENASLT equ 0x0024 ; Switches indicated slot at indicated page on perpetual
018+  0000             
019+  0000             ; Initialization-routines
020+  0000             INITIO equ 0x003B ; Initialises the device
021+  0000             INIFNK equ 0x003E ; Initialises the contents of the function keys
022+  0000             
023+  0000             ; VDP routines
024+  0000             DISSCR equ 0x0041 ; inhibits the screen display
025+  0000             ENASCR equ 0x0044 ; displays the screen
026+  0000             WRTVDP equ 0x0047 ; write data in the VDP-register
027+  0000             RDVRM  equ 0x004A ; Reads the content of VRAM
028+  0000             WRTVRM equ 0x004D ; Writes data in VRAM
029+  0000             SETRD  equ 0x0050 ; Enable VDP to read
030+  0000             SETWRT equ 0x0053 ; Enable VDP to write
031+  0000             FILVRM equ 0x0056 ; fill VRAM with value
032+  0000             LDIRMV equ 0x0059 ; Block transfer to memory from VRAM
033+  0000             LDIRVM equ 0x005C ; Block transfer to VRAM from memory
034+  0000             CHGMOD equ 0x005F ; Switches to given screenmode
035+  0000             CHGCLR equ 0x0062 ; Changes the screencolors
036+  0000             CLRSPR equ 0x0069 ; Initialises all sprites
037+  0000             INITXT equ 0x006C ; Switches to SCREEN 0 (text screen with 40 * 24 characters)
038+  0000             INIT32 equ 0x006F ; Switches to SCREEN 1 (text screen with 32*24 characters)
039+  0000             INIGRP equ 0x0072 ; Switches to SCREEN 2 (high resolution screen with 256*192 pixels)
040+  0000             INIMLT equ 0x0075 ; Switches to SCREEN 3 (multi-color screen 64*48 pixels)
041+  0000             SETTXT equ 0x0078 ; Switches to VDP in SCREEN 0 mode
042+  0000             SETT32 equ 0x007B ; Switches VDP in SCREEN mode 1
043+  0000             SETGRP equ 0x007E ; Switches VDP to SCREEN 2 mode
044+  0000             SETMLT equ 0x0081 ; Switches VDP to SCREEN 3 mode
045+  0000             CALPAT equ 0x0084 ; Returns the address of the sprite pattern table
046+  0000             CALATR equ 0x0087 ; Returns the address of the sprite attribute table
047+  0000             GSPSIZ equ 0x008A ; Returns current sprite size
048+  0000             GRPPRT equ 0x008D ; Displays a character on the graphic screen
049+  0000                     
050+  0000             ; PSG routines
051+  0000             GICINI equ 0x0090 ; Initialises PSG and sets initial value for the PLAY statement
052+  0000             WRTPSG equ 0x0093 ; Writes data to PSG-register
053+  0000             ;Input    : A  - PSG register number
054+  0000             ;           E  - Data write
055+  0000             RDPSG  equ 0x0096 ; Reads value from PSG-register
056+  0000             STRTMS equ 0x0099 ; Tests whether the PLAY statement is being executed as a background task. If not, begins to execute the PLAY statement  */
057+  0000             
058+  0000             ; Console routines, rutinas de consola
059+  0000             CHSNS  equ 0x009C ; Tests the status of the keyboard buffer
060+  0000             CHGET  equ 0x009F ; One character input (waiting)
061+  0000             CHPUT  equ 0x00A2 ; Displays one character
062+  0000             LPTOUT equ 0x00A5 ; Sends one character to printer
063+  0000             LPTSTT equ 0x00A8 ; Tests printer status
064+  0000             CNVCHR equ 0x00AB ; tests for the graphic header and transforms the code
065+  0000             PINLIN equ 0x00AE ; Stores in the specified buffer the character codes input until the return key or STOP key is pressed     */
066+  0000             INLIN  equ 0x00B1 ; Same as PINLIN except that AUGFLG (#F6AA) is set
067+  0000             QINLIN equ 0x00B4 ; Prints a questionmark andone space
068+  0000             BREAKX equ 0x00B7 ; Tests status of CTRL-STOP 
069+  0000             ISCNTC equ 0x00BA ; Tests status of SHIFT-STOP 
070+  0000             CKCNTC equ 0x00BD ; Same as ISCNTC. used in Basic
071+  0000             BEEP   equ 0x00C0 ; generates beep
072+  0000             BCLS   equ 0x00C3 ; Clears the screen
073+  0000             POSIT  equ 0x00C6 ; Places the cursor at the specified location
074+  0000             FNKSB  equ 0x00C9 ; Tests whether the function key display is active (FNKFLG)If so, displays them, otherwise erase them */
075+  0000             ERAFNK equ 0x00CC ; Erase functionkey display
076+  0000             DSPFNK equ 0x00CF ; Displays the function keys
077+  0000             TOTEXT equ 0x00D2 ; Forces the screen to be in the text mode
078+  0000             
079+  0000             ; Controller routines                      
080+  0000             GTSTCK equ 0x00D5 ; Returns the joystick status
081+  0000             GTTRIG equ 0x00D8 ; Returns current trigger status
082+  0000             GTPAD  equ 0x00DB ; Returns current touch pad status
083+  0000             GTPDL  equ 0x00DE ; Returns currenct value of paddle
084+  0000             
085+  0000             ; Tape device routines                      
086+  0000             TAPION equ 0x00E1 ; Reads the header block after turning the cassette motor on
087+  0000             TAPIN  equ 0x00E4 ; Read data from the tape
088+  0000             TAPIOF equ 0x00E7 ; Stops reading from the tape
089+  0000             TAPOON equ 0x00EA ; Turns on the cassette motor and writes the header
090+  0000             TAPOUT equ 0x00ED ; Writes data on the tape
091+  0000             TAPOOF equ 0x00F0 ; Stops writing on the tape
092+  0000             STMOTR equ 0x00F3 ; Sets the cassette motor action
093+  0000             
094+  0000             ; Queue routines                      
095+  0000             LFTQ equ 0x00F6 ; Gives number of bytes in queue
096+  0000             PUTQ equ 0x00F9 ; Put byte in queue
097+  0000             
098+  0000             ; Graphic routines
099+  0000             ;More info (MSX Assembly Page): http:;map.grauw.nl/resources/msxbios.php                      
100+  0000             RIGHTC equ 0x00FC ; Shifts screenpixel to the right
101+  0000             LEFTC  equ 0x00FF ; Shifts screenpixel to the left
102+  0000             UPC    equ 0x0102 ; Shifts screenpixel up
103+  0000             TUPC   equ 0x0105 ; Tests whether UPC is possible, if possible, execute UPC
104+  0000             DOWNC  equ 0x0108 ; Shifts screenpixel down
105+  0000             TDOWNC equ 0x010B ; Tests whether DOWNC is possible, if possible, execute DOWNC
106+  0000             SCALXY equ 0x010E ; Scales X and Y coordinates
107+  0000             MAPXY  equ 0x0111 ; Places cursor at current cursor address
108+  0000             FETCHC equ 0x0114 ; Gets current cursor addresses mask pattern
109+  0000             STOREC equ 0x0117 ; Record current cursor addresses mask pattern
110+  0000             SETATR equ 0x011A ; Set attribute byte
111+  0000             READC  equ 0x011E ; Reads attribute byte of current screenpixel
112+  0000             SETC   equ 0x0120 ; Returns currenct screenpixel of specificed attribute byte
113+  0000             NSETCX equ 0x0123 ; Set horizontal screenpixels
114+  0000             GTASPC equ 0x0126 ; Gets screen relations
115+  0000             PNTINI equ 0x0129 ; Initalises the PAINT instruction
116+  0000             SCANR  equ 0x012C ; Scans screenpixels to the right
117+  0000             SCANL  equ 0x012F ; Scans screenpixels to the left
118+  0000             
119+  0000             ; Graphic routines MSX2 
120+  0000             ;More info (MSX Assembly Page): http:;map.grauw.nl/resources/msxbios.php#msx2bios
121+  0000             CHKNEW equ 0x0165 ;Tests screen mode > C-flag set if screenmode = 5, 6, 7 or 8
122+  0000             BIGFIL equ 0x016B ;fill VRAM with value (total VRAM can be reached) HL address, BC length, A data
123+  0000             NSETRD equ 0x016E ;Enable VDP to read.(with full 16 bits VRAM-address)
124+  0000             NSTWRT equ 0x0171 ;Enable VDP to write.(with full 16 bits VRAM-address) 
125+  0000             NRDVRM equ 0x0174 ;Reads VRAM like in RDVRM.(with full 16 bits VRAM-address)
126+  0000             NWRVRM equ 0x0177 ;Writes to VRAM like in WRTVRM.(with full 16 bits VRAM-address)
127+  0000             
128+  0000                                  
129+  0000             ; Misc routines
130+  0000             CHGCAP equ 0x0132 ; Alternates the CAP lamp status
131+  0000             CHGSND equ 0x0135 ; Alternates the 1-bit sound port status
132+  0000             RSLREG equ 0x0138 ; Reads the primary slot register
133+  0000             WSLREG equ 0x013B ; Writes value to the primary slot register
134+  0000             RDVDP  equ 0x013E ; Reads VDP status register
135+  0000             SNSMAT equ 0x0141 ; Returns the value of the specified line from the keyboard matrix
136+  0000             ; 0   1          2           3           4           5           6           7           8       9       10
137+  0000             ;0    1          2                      4           5           6
138+  0000             ;1   ; fin grabr ' grabar                                                    Ñ
139+  0000             ;2                                      \grabar2  DEADfingrabar2 A           B
140+  0000             ;3 C                        F           G           H
141+  0000             ;4                          N
142+  0000             ;5 S                        V                       X                       Z
143+  0000             ;6SHIFtONTROL    GRAPH      CAPS        CODE
144+  0000             ;7              ESCAPE                              BS                      RET
145+  0000             ;8                                               Cursor ^    Cursor v
146+  0000             PHYDIO equ 0x0144 ; Executes I/O for mass-storage media like diskettes
147+  0000             FORMAT equ 0x0147 ; Initialises mass-storage media like formatting of diskettes
148+  0000             ISFLIO equ 0x014A ; Tests if I/O to device is taking place
149+  0000             OUTDLP equ 0x014E ; Printer output
150+  0000             GETVCP equ 0x0150 ; Returns pointer to play queue
151+  0000             GETVC2 equ 0x0153 ; Returns pointer to variable in queue number VOICEN (byte op #FB38)
152+  0000             KILBUF equ 0x0156 ; Clear keyboard buffer
153+  0000             CALBAS equ 0x0159 ; Executes inter-slot call to the routine in BASIC interpreter
154+  0000                     
155+  0000             
003   0000 FE              db   0FEh               ; ID archivo binario, siempre hay que poner el mismo 0FEh
004   0001 00 C0           dw   INICIO             ; dirección de inicio
005   0003 1D C0           dw   FINAL - 1          ; dirección final
006   0005 00 C0           dw   MAIN               ; dircción del programa de ejecución (para cuando pongas r en bload"nombre_programa", r)
007   0007                 
008   0007                  
009   0007              
010   0007                 org #c000              ; org se utiliza para decirle al z80 en que posición de memoria empieza nuestro programa (es la 33280 en decimal), en hezadecimal sería #8200
011   C000                     
012   C000             INICIO: 
013   C000             
014   C000             ;esta es la entrada principal
015   C000             MAIN: 
016   C000 CD 07 C0    	call mensaje
017   C003 CD 1C C0    	call bucle
018   C006 C9          	ret
019   C007             
020   C007             mensaje: 
021   C007 3E 68       	ld a,'h'
022   C009 CD A2 00    	call CHPUT 
023   C00C 3E 6F       	ld a,'o'
024   C00E CD A2 00    	call CHPUT 
025   C011 3E 6C       	ld a,'l'
026   C013 CD A2 00    	call CHPUT 
027   C016 3E 61       	ld a,'a'
028   C018 CD A2 00    	call CHPUT 
029   C01B C9          	ret
030   C01C             
031   C01C             bucle: 
032   C01C 18 FE       	jr bucle
033   C01E             
034   C01E             
035   C01E                 
036   C01E                 
037   C01E                 
038   C01E                
039   C01E                  
040   C01E              
041   C01E             FINAL: 
