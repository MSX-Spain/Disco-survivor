src/map-screen1.asm(2): error: Duplicate label: SCREEN_0_0
001   0000                 output "main.bin"
002   0000             
003   0000 FE              db   0FEh               ; ID archivo binario, siempre hay que poner el mismo 0FEh
004   0001 00 C0           dw   INICIO             ; dirección de inicio
005   0003 97 CA           dw   FINAL - 1          ; dirección final
006   0005 DD C2           dw   MAIN               ; dircción del programa de ejecución (para cuando pongas r en bload"nombre_programa", r)
007   0007                 
008   0007                  
009   0007              
010   0007                 org #c000              ; org se utiliza para decirle al z80 en que posición de memoria empieza nuestro programa (es la 33280 en decimal), en hezadecimal sería #8200
011   C000                     
012   C000             INICIO: 
013   C000             
014   C000             
015   C000 00          screen:  db 0
016   C001             message_level:  db "Level",0
016   C001 4C6576656C00
017   C007             message_lives:  db "Lives",0
017   C007 4C6976657300
018   C00D             message_score:  db "Score",0
018   C00D 53636F726500
019   C013             message_msx_spain:  db "MSX spain",0 
019   C013 4D535820737061696E00
020   C01D 00          map_buffer:  ds 704 ;768-64 es el mapa o tabla de nombres de VRAM copiada aquí
021   C2DD             
022   C2DD             
023   C2DD             MAIN: 
024   C2DD CD A9 C3    	call initialize_player
025   C2E0 CD 89 C4    	call initialize_enemy
026   C2E3 CD 17 C3        call hud
027   C2E6 CD 75 C3        call load_screen_0
028   C2E9 CD ED C2    	call main_loop
029   C2EC C9          	ret
030   C2ED             
031   C2ED             main_loop: 
032   C2ED 76          	halt
033   C2EE CD FD C2    	call cursors
034   C2F1 CD C2 C3    	call update_player
035   C2F4 DD E5           push ix
036   C2F6 CD A6 C4        call update_enemy
037   C2F9 DD E1           pop ix
038   C2FB 18 F0       	jr main_loop
039   C2FD             
040   C2FD             
041   C2FD             
042   C2FD             
043   C2FD             
044   C2FD             cursors: 
045   C2FD 3E 00           ld a,0
046   C2FF CD D5 00        call GTSTCK
047   C302                 
048   C302 FE 01           cp 1
049   C304 CA 0D C4        jp z, move_player_up
050   C307                 ;cp 2
051   C307                 ;jp z, move_player_up_right
052   C307 FE 03           cp 3
053   C309 CA CF C3        jp z, move_player_right
054   C30C                 ;cp 4
055   C30C                 ;jp z, move_player_down_right
056   C30C FE 05           cp 5
057   C30E CA 2C C4        jp z, move_player_down
058   C311                 ;cp 6
059   C311                 ;jp z, move_player_down_left
060   C311 FE 07           cp 7
061   C313 CA EE C3        jp z, move_player_left
062   C316                 ;cp 8
063   C316                 ;jp z, move_player_up_left
064   C316 C9              ret
065   C317             
066   C317             
067   C317             hud: 
068   C317 3E 0A           ld a,10
069   C319 32 B7 FC        ld (GRPACX),a ;GRPACX contiene la posición X del cursor en modo gráfico
070   C31C 3E B4           ld a,180
071   C31E 32 B9 FC        ld (GRPACY),a
072   C321 21 01 C0        ld hl, message_level
073   C324 CD 4C C3        call print
074   C327             
075   C327 3E 3A           ld a,58; posicionamos el cursor en la posición x 58
076   C329 32 B7 FC        ld (GRPACX),a
077   C32C                 ;metemos en b el valor correspondiente al 0 en la tabla ascii
078   C32C 06 30           ld b,48
079   C32E                 ;para sumar a y b tendremos que echar mano de ld a
080   C32E 3A 00 C0        ld a,(screen)
081   C331 80              add b
082   C332 CD 8D 00        call GRPPRT 
083   C335             
084   C335 3E 50           ld a,80
085   C337 32 B7 FC        ld (GRPACX),a
086   C33A 21 0D C0        ld hl, message_score
087   C33D CD 4C C3        call print
088   C340             
089   C340             
090   C340 3E B4           ld a,180
091   C342 32 B7 FC        ld (GRPACX),a
092   C345 21 13 C0        ld hl, message_msx_spain
093   C348 CD 4C C3        call print
094   C34B C9              ret
095   C34C             
096   C34C             print: 
097   C34C 7E              ld  a,(hl)          ; Lee el 1 byte de la dirección de la memoria indicada y lo almacena en el registro a del z80.
098   C34D A7              and a               ; Actualiza la bandera z del registro F del z80 y la pone en 0 si no hay valor, and a también actualiza el flag c, p, v y s.
099   C34E C8              ret z               ; Devuelve el cotrol al Main si la bandera z del registro F del z80 es 0
100   C34F CD 8D 00        call GRPPRT         ; Llama a la subrutina 0042h de la Bios la cual imprime el caracter almacenado en el registro a del z80
101   C352 23              inc hl              ; incrementa el puntero de los registros hl para que señale al siguiente byte
102   C353 18 F7           jr print            ; Llama al métdo print para que lo vuelva a ejecutar
103   C355                  
104   C355             
105   C355             
106   C355             
107   C355             
108   C355             
109   C355             
110   C355             
111   C355             
112   C355             
113   C355             
114   C355             
115   C355             
116   C355             
117   C355             
118   C355             
119   C355             increase_screen: 
120   C355 3E 96           ld a,150
121   C357 DD 77 00        ld (ix+player.y),a
122   C35A 3E 00           ld a,0
123   C35C DD 77 01        ld (ix+player.x),a
124   C35F 3A 00 C0        ld a,(screen)
125   C362 C6 01           add 1
126   C364 32 00 C0        ld (screen),a
127   C367                 
128   C367 CD C3 00        call BCLS
129   C36A                 
130   C36A             
131   C36A             
132   C36A FE 00           cp 0
133   C36C CA 75 C3    	jp z, load_screen_0
134   C36F FE 01           cp 1
135   C371 CA 8D C3    	jp z, load_screen_1
136   C374             
137   C374                    
138   C374 C9              ret
139   C375             load_screen_0: 
140   C375                 ;ponemos el mapa en el byffer para hacer las colisiones
141   C375 21 18 C5        ld hl, map_screen0
142   C378 11 1D C0        ld de, map_buffer 
143   C37B 01 C0 02        ld bc, 768-64
144   C37E ED B0           LDIR
145   C380                 ;ponemos el mapa en la VRAM
146   C380 21 1D C0        ld hl, map_buffer
147   C383 11 00 18        ld de, 6144 
148   C386             	;Le quitamos 64 ya que keremos pintar el HUD en las últimas 2 líneas de la pantalla
149   C386 01 C0 02        ld bc, 768-64
150   C389 CD 5C 00        call  LDIRVM
151   C38C C9              ret
152   C38D             load_screen_1: 
153   C38D 21 D8 C7        ld hl, map_screen1
154   C390 11 1D C0        ld de, map_buffer 
155   C393 01 C0 02        ld bc, 768-64
156   C396 ED B0           LDIR
157   C398 21 1D C0        ld hl, map_buffer
158   C39B 11 00 18        ld de, 6144 
159   C39E 01 C0 02        ld bc, 768-64
160   C3A1 CD 5C 00        call  LDIRVM
161   C3A4 CD 17 C3        call hud
162   C3A7 C9              ret
163   C3A8             
164   C3A8             
165   C3A8             
166   C3A8             
167   C3A8             
168   C3A8             
169   C3A8             
170   C3A8              
171   C3A8             
172   C3A8             
173   C3A8             
174   C3A8             
175   C3A8                 
176   C3A8             	include "src/vars_msxBios.asm"    
001+  C3A8             ;ver las instruciones del z80: http://clrhome.org/table/
002+  C3A8             ;ver las instrucciones de la bios: https://map.grauw.nl/resources/msxbios.php
003+  C3A8             ;ver las instrucciones: https://www.msx.org/wiki/Z80_Assembler_for_Dummies
004+  C3A8             
005+  C3A8             ; use RST assembler mnemonic to call
006+  C3A8             CHKRAM equ 0x00 ; RST 0x00 > Check RAM and sets slot for command area.
007+  C3A8             SYNCHR equ 0x08 ; RST	0x08 > Checks if then current character pointed by HL is one desired.
008+  C3A8             CHRGTR equ 0x10 ; RST	0x10 > Gets the next character (or token) of the Basic-text
009+  C3A8             OUTDO  equ 0x18 ; RST	0x18 > Output to current outputchannel (printer, diskfile, etc.)
010+  C3A8             DCOMPR equ 0x20 ; RST	0x20 > Compares HL with DE
011+  C3A8             GETYPR equ 0x28 ; RST	0x28 > Returns Type of DAC
012+  C3A8             CALLF  equ 0x30 ; RST	0x30 > Executes an interslot call
013+  C3A8             KEYINT equ 0x38 ; RST	0x38 > Executes the timer interrupt process routine
014+  C3A8             
015+  C3A8             ; use CALL assembler mnemonic
016+  C3A8             RDSLT  equ 0x000C ; Reads the value of an address in another slot
017+  C3A8             WRSLT  equ 0x0014 ; Writes a value to an address in another slot
018+  C3A8             CALSLT equ 0x001C ; Executes inter-slot call
019+  C3A8             ENASLT equ 0x0024 ; Switches indicated slot at indicated page on perpetual
020+  C3A8             
021+  C3A8             ; Initialization-routines
022+  C3A8             INITIO equ 0x003B ; Initialises the device
023+  C3A8             INIFNK equ 0x003E ; Initialises the contents of the function keys
024+  C3A8             
025+  C3A8             ; VDP routines
026+  C3A8             DISSCR equ 0x0041 ; inhibits the screen display
027+  C3A8             ENASCR equ 0x0044 ; displays the screen
028+  C3A8             WRTVDP equ 0x0047 ; write data in the VDP-register, B  - Data to write, C  - Number of the register
029+  C3A8             RDVRM  equ 0x004A ; Reads the content of VRAM
030+  C3A8             WRTVRM equ 0x004D ; Writes data in VRAM
031+  C3A8             SETRD  equ 0x0050 ; Enable VDP to read
032+  C3A8             SETWRT equ 0x0053 ; Enable VDP to write
033+  C3A8             FILVRM equ 0x0056 ; fill VRAM with value
034+  C3A8             LDIRMV equ 0x0059 ; Block transfer to memory from VRAM
035+  C3A8             LDIRVM equ 0x005C ; Block transfer to VRAM from memory
036+  C3A8             CHGMOD equ 0x005F ; Switches to given screenmode
037+  C3A8             CHGCLR equ 0x0062 ; Changes the screencolors
038+  C3A8             CLRSPR equ 0x0069 ; Initialises all sprites
039+  C3A8             INITXT equ 0x006C ; Switches to SCREEN 0 (text screen with 40 * 24 characters)
040+  C3A8             INIT32 equ 0x006F ; Switches to SCREEN 1 (text screen with 32*24 characters)
041+  C3A8             INIGRP equ 0x0072 ; Switches to SCREEN 2 (high resolution screen with 256*192 pixels)
042+  C3A8             INIMLT equ 0x0075 ; Switches to SCREEN 3 (multi-color screen 64*48 pixels)
043+  C3A8             SETTXT equ 0x0078 ; Switches to VDP in SCREEN 0 mode
044+  C3A8             SETT32 equ 0x007B ; Switches VDP in SCREEN mode 1
045+  C3A8             SETGRP equ 0x007E ; Switches VDP to SCREEN 2 mode
046+  C3A8             SETMLT equ 0x0081 ; Switches VDP to SCREEN 3 mode
047+  C3A8             CALPAT equ 0x0084 ; Returns the address of the sprite pattern table
048+  C3A8             CALATR equ 0x0087 ; Returns the address of the sprite attribute table
049+  C3A8             GSPSIZ equ 0x008A ; Returns current sprite size
050+  C3A8             GRPPRT equ 0x008D ; Displays a character on the graphic screen
051+  C3A8             FORCLR equ 0xF3E9 ;color de tinta (+1=color del fondo, +1 color del borde)
052+  C3A8                     
053+  C3A8             ; PSG routines
054+  C3A8             GICINI equ 0x0090 ; Initialises PSG and sets initial value for the PLAY statement
055+  C3A8             WRTPSG equ 0x0093 ; Writes data to PSG-register
056+  C3A8             ;Input    : A  - PSG register number
057+  C3A8             ;           E  - Data write
058+  C3A8             RDPSG  equ 0x0096 ; Reads value from PSG-register
059+  C3A8             STRTMS equ 0x0099 ; Tests whether the PLAY statement is being executed as a background task. If not, begins to execute the PLAY statement  */
060+  C3A8             
061+  C3A8             ; Console routines, rutinas de consola
062+  C3A8             CHSNS  equ 0x009C ; Tests the status of the keyboard buffer
063+  C3A8             CHGET  equ 0x009F ; One character input (waiting)
064+  C3A8             CHPUT  equ 0x00A2 ; Displays one character
065+  C3A8             LPTOUT equ 0x00A5 ; Sends one character to printer
066+  C3A8             LPTSTT equ 0x00A8 ; Tests printer status
067+  C3A8             CNVCHR equ 0x00AB ; tests for the graphic header and transforms the code
068+  C3A8             PINLIN equ 0x00AE ; Stores in the specified buffer the character codes input until the return key or STOP key is pressed     */
069+  C3A8             INLIN  equ 0x00B1 ; Same as PINLIN except that AUGFLG (#F6AA) is set
070+  C3A8             QINLIN equ 0x00B4 ; Prints a questionmark andone space
071+  C3A8             BREAKX equ 0x00B7 ; Tests status of CTRL-STOP 
072+  C3A8             ISCNTC equ 0x00BA ; Tests status of SHIFT-STOP 
073+  C3A8             CKCNTC equ 0x00BD ; Same as ISCNTC. used in Basic
074+  C3A8             BEEP   equ 0x00C0 ; generates beep
075+  C3A8             BCLS   equ 0x00C3 ; Clears the screen
076+  C3A8             POSIT  equ 0x00C6 ; Places the cursor at the specified location
077+  C3A8             FNKSB  equ 0x00C9 ; Tests whether the function key display is active (FNKFLG)If so, displays them, otherwise erase them */
078+  C3A8             ERAFNK equ 0x00CC ; Erase functionkey display
079+  C3A8             DSPFNK equ 0x00CF ; Displays the function keys
080+  C3A8             TOTEXT equ 0x00D2 ; Forces the screen to be in the text mode
081+  C3A8             
082+  C3A8             ; Controller routines                      
083+  C3A8             GTSTCK equ 0x00D5 ; Returns the joystick status
084+  C3A8             GTTRIG equ 0x00D8 ; Returns current trigger status
085+  C3A8             GTPAD  equ 0x00DB ; Returns current touch pad status
086+  C3A8             GTPDL  equ 0x00DE ; Returns currenct value of paddle
087+  C3A8             
088+  C3A8             ; Tape device routines                      
089+  C3A8             TAPION equ 0x00E1 ; Reads the header block after turning the cassette motor on
090+  C3A8             TAPIN  equ 0x00E4 ; Read data from the tape
091+  C3A8             TAPIOF equ 0x00E7 ; Stops reading from the tape
092+  C3A8             TAPOON equ 0x00EA ; Turns on the cassette motor and writes the header
093+  C3A8             TAPOUT equ 0x00ED ; Writes data on the tape
094+  C3A8             TAPOOF equ 0x00F0 ; Stops writing on the tape
095+  C3A8             STMOTR equ 0x00F3 ; Sets the cassette motor action
096+  C3A8             
097+  C3A8             ; Queue routines                      
098+  C3A8             LFTQ equ 0x00F6 ; Gives number of bytes in queue
099+  C3A8             PUTQ equ 0x00F9 ; Put byte in queue
100+  C3A8             
101+  C3A8             ; Graphic routines
102+  C3A8             ;More info (MSX Assembly Page): http:;map.grauw.nl/resources/msxbios.php                      
103+  C3A8             RIGHTC equ 0x00FC ; Shifts screenpixel to the right
104+  C3A8             LEFTC  equ 0x00FF ; Shifts screenpixel to the left
105+  C3A8             UPC    equ 0x0102 ; Shifts screenpixel up
106+  C3A8             TUPC   equ 0x0105 ; Tests whether UPC is possible, if possible, execute UPC
107+  C3A8             DOWNC  equ 0x0108 ; Shifts screenpixel down
108+  C3A8             TDOWNC equ 0x010B ; Tests whether DOWNC is possible, if possible, execute DOWNC
109+  C3A8             SCALXY equ 0x010E ; Scales X and Y coordinates
110+  C3A8             MAPXY  equ 0x0111 ; Places cursor at current cursor address
111+  C3A8             FETCHC equ 0x0114 ; Gets current cursor addresses mask pattern
112+  C3A8             STOREC equ 0x0117 ; Record current cursor addresses mask pattern
113+  C3A8             SETATR equ 0x011A ; Set attribute byte
114+  C3A8             READC  equ 0x011E ; Reads attribute byte of current screenpixel
115+  C3A8             SETC   equ 0x0120 ; Returns currenct screenpixel of specificed attribute byte
116+  C3A8             NSETCX equ 0x0123 ; Set horizontal screenpixels
117+  C3A8             GTASPC equ 0x0126 ; Gets screen relations
118+  C3A8             PNTINI equ 0x0129 ; Initalises the PAINT instruction
119+  C3A8             SCANR  equ 0x012C ; Scans screenpixels to the right
120+  C3A8             SCANL  equ 0x012F ; Scans screenpixels to the left
121+  C3A8             
122+  C3A8             ; Graphic routines MSX2
123+  C3A8             ;More info (MSX Assembly Page): http:;map.grauw.nl/resources/msxbios.php#msx2bios
124+  C3A8             CHKNEW equ 0x0165 ;Tests screen mode > C-flag set if screenmode = 5, 6, 7 or 8
125+  C3A8             BIGFIL equ 0x016B ;fill VRAM with value (total VRAM can be reached) HL address, BC length, A data
126+  C3A8             NSETRD equ 0x016E ;Enable VDP to read.(with full 16 bits VRAM-address)
127+  C3A8             NSTWRT equ 0x0171 ;Enable VDP to write.(with full 16 bits VRAM-address) 
128+  C3A8             NRDVRM equ 0x0174 ;Reads VRAM like in RDVRM.(with full 16 bits VRAM-address)
129+  C3A8             NWRVRM equ 0x0177 ;Writes to VRAM like in WRTVRM.(with full 16 bits VRAM-address)
130+  C3A8             
131+  C3A8             
132+  C3A8             
133+  C3A8             
134+  C3A8             
135+  C3A8             
136+  C3A8                                  
137+  C3A8             ; Misc routines
138+  C3A8             CLIKSW equ 0xF3DB; para que no se oiga el click que hace al pulsar las teclas
139+  C3A8             CHGCAP equ 0x0132 ; Alternates the CAP lamp status
140+  C3A8             CHGSND equ 0x0135 ; Alternates the 1-bit sound port status
141+  C3A8             RSLREG equ 0x0138 ; Reads the primary slot register
142+  C3A8             WSLREG equ 0x013B ; Writes value to the primary slot register
143+  C3A8             RDVDP  equ 0x013E ; Reads VDP status register
144+  C3A8             SNSMAT equ 0x0141 ; Returns the value of the specified line from the keyboard matrix
145+  C3A8             ; 0   1          2           3           4           5           6           7           8       9       10
146+  C3A8             ;0    1          2                      4           5           6
147+  C3A8             ;1   ; fin grabr ' grabar                                                    Ñ
148+  C3A8             ;2                                      \grabar2  DEADfingrabar2 A           B
149+  C3A8             ;3 C                        F           G           H
150+  C3A8             ;4                          N
151+  C3A8             ;5 S                        V                       X                       Z
152+  C3A8             ;6SHIFtONTROL    GRAPH      CAPS        CODE
153+  C3A8             ;7              ESCAPE                              BS                      RET
154+  C3A8             ;8                                               Cursor ^    Cursor v
155+  C3A8             PHYDIO equ 0x0144 ; Executes I/O for mass-storage media like diskettes
156+  C3A8             FORMAT equ 0x0147 ; Initialises mass-storage media like formatting of diskettes
157+  C3A8             ISFLIO equ 0x014A ; Tests if I/O to device is taking place
158+  C3A8             OUTDLP equ 0x014E ; Printer output
159+  C3A8             GETVCP equ 0x0150 ; Returns pointer to play queue
160+  C3A8             GETVC2 equ 0x0153 ; Returns pointer to variable in queue number VOICEN (byte op #FB38)
161+  C3A8             KILBUF equ 0x0156 ; Clear keyboard buffer
162+  C3A8             CALBAS equ 0x0159 ; Executes inter-slot call to the routine in BASIC interpreter
163+  C3A8                     
164+  C3A8             
177   C3A8             	include "src/vars_msxSystem.asm"    
001+  C3A8             ; Graphic variables                 
002+  C3A8             GRPACX equ 0xFCB7  ; posicionar cursor en modo gráfico
003+  C3A8             GRPACY equ 0xFCB9
178   C3A8             	include "src/player.asm"    
001+  C3A8             ;player_atributes: ds 4,0
002+  C3A8             player_atributes: 
003+  C3A8                 struct player 
004+  C3A8~            y       db      0
005+  C3A8~            x       db      0
006+  C3A8~            plane   db      0
007+  C3A8~            color   db      0
008+  C3A8                 ends
009+  C3A8 00          tile0:  db 0
010+  C3A9             
011+  C3A9             
012+  C3A9             initialize_player: 
013+  C3A9 DD 21 A8 C3     ld ix, player_atributes
014+  C3AD 3E A0           ld a,160
015+  C3AF DD 77 00        ld (ix+player.y),a ;le ponemos a la posición y un 160
016+  C3B2 3E 00           ld a,0 
017+  C3B4 DD 77 01        ld (ix+player.x),a ;le ponemos a la posición x 120
018+  C3B7 3E 00           ld a,0
019+  C3B9 DD 77 02        ld (ix+player.plane),a ;Le ponemos el patrón 0
020+  C3BC 3E 0B           ld a,11 ; el 11 es el color amarillo
021+  C3BE DD 77 03        ld (ix+player.color),a 
022+  C3C1 C9              ret
023+  C3C2             update_player: 
024+  C3C2 21 A8 C3        ld hl, player_atributes 
025+  C3C5 11 00 1B        ld de, 6912 ;#1b00 dirección tabla de atributos en VRAM    
026+  C3C8 01 04 00        ld bc, 4; 4 bytes para copiar
027+  C3CB CD 5C 00        call  LDIRVM 
028+  C3CE C9              ret
029+  C3CF             
030+  C3CF             
031+  C3CF             move_player_right: 
032+  C3CF DD 7E 01        ld a,(ix+player.x); obtenemos el valor actual de la posicion x
033+  C3D2 C6 01           add 1; incrementamos en 1 el valor
034+  C3D4 DD 77 01        ld (ix+player.x), a ; se lo metemos al atributo posicion X
035+  C3D7 E6 01           and 1
036+  C3D9 CA E5 C3        jp z, right_es_impar
037+  C3DC 3E 00           ld a, 0
038+  C3DE DD 77 02        ld (ix+player.plane),a ;le metemos el sprite que mira hacia la derecha 2
039+  C3E1 CD 4B C4        call checkColision
040+  C3E4 C9              ret
041+  C3E5             right_es_impar: 
042+  C3E5 3E 04           ld a, 1*4
043+  C3E7 DD 77 02        ld (ix+player.plane),a ;le metemos el sprite que mira hacia la derecha 2
044+  C3EA CD 4B C4        call checkColision
045+  C3ED C9              ret
046+  C3EE             move_player_left: 
047+  C3EE DD 7E 01        ld a,(ix+player.x); 
048+  C3F1 D6 01           sub 1  
049+  C3F3 DD 77 01        ld (ix+player.x), a 
050+  C3F6 E6 01           and 1
051+  C3F8 CA 04 C4        jp z, left_es_impar
052+  C3FB 3E 08           ld a, 2*4 
053+  C3FD DD 77 02        ld (ix+player.plane),a
054+  C400 CD 4B C4        call checkColision
055+  C403 C9              ret
056+  C404             left_es_impar: 
057+  C404 3E 0C           ld a, 3*4
058+  C406 DD 77 02        ld (ix+player.plane),a 
059+  C409 CD 4B C4        call checkColision
060+  C40C C9              ret
061+  C40D             move_player_up: 
062+  C40D DD 7E 00        ld a,(ix+player.y)
063+  C410 D6 01           sub 1 
064+  C412 DD 77 00        ld (ix+player.y), a 
065+  C415 E6 01           and 1
066+  C417 CA 23 C4        jp z, up_es_impar
067+  C41A 3E 10           ld a, 4*4
068+  C41C DD 77 02        ld (ix+player.plane),a
069+  C41F CD 4B C4        call checkColision
070+  C422 C9              ret
071+  C423             up_es_impar: 
072+  C423 3E 14           ld a, 5*4
073+  C425 DD 77 02        ld (ix+player.plane),a 
074+  C428 CD 4B C4        call checkColision
075+  C42B C9              ret
076+  C42C             move_player_down: 
077+  C42C DD 7E 00        ld a,(ix+player.y)
078+  C42F C6 01           add 1 
079+  C431 DD 77 00        ld (ix+player.y), a 
080+  C434 E6 01           and 1
081+  C436 CA 42 C4        jp z, down_es_impar
082+  C439 3E 18           ld a, 6*4
083+  C43B DD 77 02        ld (ix+player.plane),a
084+  C43E CD 4B C4        call checkColision
085+  C441 C9              ret
086+  C442             down_es_impar: 
087+  C442 3E 1C           ld a, 7*4
088+  C444 DD 77 02        ld (ix+player.plane),a 
089+  C447 CD 4B C4        call checkColision
090+  C44A C9              ret
091+  C44B             
092+  C44B             
093+  C44B             checkColision: 
094+  C44B A8              xor b
095+  C44C CD 5E C4        call dame_el_tile_que_hay_en_x_e_y
096+  C44F 78              ld a,b
097+  C450 FE 2B           cp 43
098+  C452 CA 55 C3        jp z,increase_screen
099+  C455 FE 20           cp 32 ;Si al restalo entre 32 da negatico se activará el flag de carry
100+  C457 30 01           jr nc, colision_player ; si al restarlo  es negativo y dará carry, si no hay está bien
101+  C459 C9              ret
102+  C45A             
103+  C45A             colision_player: 
104+  C45A CD C0 00        call BEEP
105+  C45D             
106+  C45D C9              ret
107+  C45E             
108+  C45E             ;----------------------------------
109+  C45E             ;Vamos a hacer esta formula (y/8)*32+(x/8)
110+  C45E             ;esta es la parte (y/8)*32
111+  C45E             ;d tiene la posicion de x
112+  C45E             ;e tiene la posicion de y
113+  C45E             dame_el_tile_que_hay_en_x_e_y: 
114+  C45E AF              xor a
115+  C45F DD 7E 00        ld a,(ix+player.y) ;a=posicion y en pixeles
116+  C462 C6 10           add 16
117+  C464                 ;con srl estas dividiendo entre 2,ya que corre a la derecha los bits. 
118+  C464                 ;al hacerlo 3 veces es como dividir entre 8,a=y/8: 1.01001100, 2.00100110, 3.00010011
119+  C464 CB 3F           srl a  
120+  C466 CB 3F           srl a  
121+  C468 CB 3F           srl a  
122+  C46A 26 00           ld h,0 ; en h le ponemos un 0 
123+  C46C 6F              ld l,a ;y en los 8 bytes de "l" le ponemos el valor que contiene a
124+  C46D             
125+  C46D                 ;-----------------
126+  C46D                 ;Buscando la fila
127+  C46D 29              add hl, hl ;x32, sumar algo por si mismo es como multiplizarlo por 2, si lo repetivos 5 es como si o multiplixaramos por 32
128+  C46E 29              add hl, hl 
129+  C46F 29              add hl, hl 
130+  C470 29              add hl, hl 
131+  C471 29              add hl, hl 
132+  C472             
133+  C472                 ;-----------------
134+  C472                 ;Esta es la parte +(x/8)
135+  C472 DD 7E 01        ld a,(ix+player.x) ;a=x
136+  C475 C6 08           add 8
137+  C477 CB 3F           srl a 
138+  C479 CB 3F           srl a 
139+  C47B CB 3F           srl a 
140+  C47D 16 00           ld d,0
141+  C47F 5F              ld e,a ;e=x
142+  C480 19              add hl,de ;hl=(y/8)*32+(x/8)
143+  C481             
144+  C481 11 1D C0        ld de, map_buffer; dirección buffer colisiones
145+  C484 19              add hl,de ;hl=buffer_colisiones + (y/8)*32+(x/8)
146+  C485             
147+  C485 46              ld b,(hl) ;metemos en a el tile que nos pide
148+  C486                 ;ld (tile0),a
149+  C486 C9              ret
150+  C487             
179   C487             	include "src/enemies.asm"    
001+  C487             enemy_atributes: 
002+  C487                 struct enemy 
003+  C487~            y       db      0
004+  C487~            x       db      0
005+  C487~            plane   db      0
006+  C487~            color   db      0
007+  C487                 ends
008+  C487 0E 0A       randData:  db 14,10
009+  C489             
010+  C489             
011+  C489             initialize_enemy: 
012+  C489 DD E5           push ix
013+  C48B DD 21 87 C4     ld ix, enemy_atributes
014+  C48F 3E 82           ld a,130
015+  C491 DD 77 00        ld (ix+enemy.y),a ;le ponemos a la posición y un 130
016+  C494 3E FF           ld a,255
017+  C496 DD 77 01        ld (ix+enemy.x),a ;le ponemos a la posición x 255
018+  C499 3E 20           ld a,8*4
019+  C49B DD 77 02        ld (ix+enemy.plane),a ;Le ponemos el patrón 8
020+  C49E 3E 04           ld a,4 ; el 4 es el color azul oscuro
021+  C4A0 DD 77 03        ld (ix+enemy.color),a 
022+  C4A3 DD E1           pop ix
023+  C4A5 C9              ret
024+  C4A6             update_enemy: 
025+  C4A6 DD 21 87 C4     ld ix, enemy_atributes
026+  C4AA                 ;obtenemos la posición x
027+  C4AA DD 7E 01        ld a,(ix+enemy.x)
028+  C4AD                 ;si la posición x es 0
029+  C4AD FE 08           cp 8
030+  C4AF CA B5 C4        jp z, recolocar_enemy
031+  C4B2 C2 C3 C4        jp nz, pintar_enemy
032+  C4B5             recolocar_enemy: 
033+  C4B5                 ;call rand16
034+  C4B5 CD 05 C5        call random
035+  C4B8                 ;ld a,(SEED)
036+  C4B8 3A 87 C4        ld a,(randData)
037+  C4BB DD 77 00        ld (ix+enemy.y),a
038+  C4BE 3E FA           ld a,250
039+  C4C0 DD 77 01        ld (ix+enemy.x),a
040+  C4C3             pintar_enemy: 
041+  C4C3 CD EC C4        call move_enemy_left
042+  C4C6 21 87 C4        ld hl, enemy_atributes 
043+  C4C9                 ;#1b00 dirección tabla de atributos en VRAM  
044+  C4C9 11 04 1B        ld de, 6912+4  ; el patron 0 es el del player, el enemigo 1 tendrá el 2 plano y como son 4 bytes=6912+4
045+  C4CC 01 04 00        ld bc, 4; 4 bytes para copiar
046+  C4CF CD 5C 00        call  LDIRVM 
047+  C4D2                 ;pop ix
048+  C4D2 C9              ret
049+  C4D3             
050+  C4D3             
051+  C4D3             move_enemy_right: 
052+  C4D3 DD 7E 01        ld a,(ix+enemy.x); obetenemos el valor actual de la posicion x y lo almacenamos en el a-cumulador
053+  C4D6 C6 01           add 1; incrementamos el valor que hay en a en 1
054+  C4D8 DD 77 01        ld (ix+enemy.x), a ; se lo metemos al atributo posicion X
055+  C4DB E6 01           and 1 ;con 0000 0001 obtenemos en a un 0 si es par ...00,...10 o un 1 si es ...01,...11, es decir, activa el flag z con los impares
056+  C4DD CA E6 C4        jp z, enemy_right_es_impar
057+  C4E0 3E 20           ld a, 8*4
058+  C4E2 DD 77 02        ld (ix+enemy.plane),a ;le metemos el sprite que mira hacia la derecha 2
059+  C4E5 C9              ret
060+  C4E6             enemy_right_es_impar: 
061+  C4E6 3E 24           ld a, 9*4
062+  C4E8 DD 77 02        ld (ix+enemy.plane),a ;le metemos el sprite que mira hacia la derecha 2
063+  C4EB C9              ret
064+  C4EC             move_enemy_left: 
065+  C4EC DD 7E 01        ld a,(ix+enemy.x); 
066+  C4EF D6 01           sub 1  
067+  C4F1 DD 77 01        ld (ix+enemy.x), a 
068+  C4F4 E6 01           and 1
069+  C4F6 CA FF C4        jp z, enemy_left_es_impar
070+  C4F9 3E 28           ld a, 10*4 
071+  C4FB DD 77 02        ld (ix+enemy.plane),a
072+  C4FE C9              ret
073+  C4FF             enemy_left_es_impar: 
074+  C4FF 3E 2C           ld a, 11*4
075+  C501 DD 77 02        ld (ix+enemy.plane),a ;le metemos el sprite que mira hacia la derecha 2
076+  C504 C9              ret
077+  C505             
078+  C505             
079+  C505             
080+  C505             ;https://gist.github.com/JohnConnolly0/25c65425cf4f84954585
081+  C505             ; El registro de refresco (R) en el Z80 es muy impredecible ya que se incrementa en cada ciclo.
082+  C505             ; Debido a que puede tener cualquier valor cuando se llama a esta rutina, es muy bueno para números aleatorios.
083+  C505             ; Esta rutina aumenta la aleatoriedad del número ya que forma una dirección basada en el
084+  C505             ; actualiza el estado actual del contador y accede a la memoria en esa dirección.
085+  C505             random: 
086+  C505 ED 5F           LD A,R			; Cargo el registro A con el registro r
087+  C507 6F              LD L,A			; Copia el valor del registro a en l
088+  C508 E6 3F           AND %00111111	; 63,#3f,Este enmascaramiento impide que la dirección que estamos formando acceda a la RAM
089+  C50A 67              LD H,A			; Copy register A into register H
090+  C50B 7E              LD A,(HL)		; Load the pseudo-random value into A
091+  C50C                 ;and %01111111  ; al hacer el 7 bit a 0 no puede tomar valores mayor de 127
092+  C50C FE 50           cp 80           ;le hacemos la resta con 100 si el resultado es menor que 0 se activará el flag de carry
093+  C50E 38 F5           jr c, random    
094+  C510 FE A0           cp 160
095+  C512 30 F1           jr nc, random
096+  C514 32 87 C4        ld (randData),a
097+  C517 C9              ret
098+  C518             
099+  C518             
100+  C518             
101+  C518             
180   C518             ;			mapas
181   C518             ;-----------------------------
182   C518             map_screen0: 
183   C518             	include "src/map-screen0.asm"
001+  C518             
src/map-screen0.asm(2): warning: Label has different value in pass 3: 50456 != 51160
002+  C518             SCREEN_0_0: 
003+  C518             	DB  38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 57, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38
003+  C518 2626262626262626262626262626262639262626262626262626262626262626
004+  C538             	DB  38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 57, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38
004+  C538 2626262626262626262626262626262639262626262626262626262626262626
005+  C558             	DB  38, 38,100,119,104,115, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 56, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38
005+  C558 2626647768732626262626262626262638262626262626262626262626262626
006+  C578             	DB  38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38
006+  C578 2626262626262626262626262626262626262626262626262626262626262626
007+  C598             	DB  38, 38, 38, 43, 44, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38
007+  C598 2626262B2C262626262626262626262626262626262626262626262626262626
008+  C5B8             	DB  38, 38, 38, 43, 45, 38,  4,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  5, 38, 38, 38, 38, 38, 38
008+  C5B8 2626262B2D260400030003000300030003000300030003000305262626262626
009+  C5D8             	DB  38, 38, 38, 43, 43,  4,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  5, 38, 38, 38, 38, 38
009+  C5D8 2626262B2B040003000300030003000300030003000300030003052626262626
010+  C5F8             	DB  38, 38, 38, 43,  4,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  5, 38, 38, 38, 38
010+  C5F8 2626262B04000300030003000300030003000300030003000300030526262626
011+  C618             	DB  38, 38, 38,  4,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  5, 38, 38, 38
011+  C618 2626260400030003000300030003000300030003000300030003000305262626
012+  C638             	DB  38, 38,  4,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  5, 38, 38
012+  C638 2626040002000200020002000200020002000200020002000200020002052626
013+  C658             	DB  38,  4,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  5, 38
013+  C658 2604000200020002000200020002000200020002000200020002000200020526
014+  C678             	DB   4,  0,  2,  0,  2,  0,  2, 50,  2,  0,  2, 51,  2,  0,  2, 50,  2,  0,  2,  0,  2,  0,  2,  0, 50,  0,  2,  0,  2,  0,  2,  5
014+  C678 0400020002000232020002330200023202000200020002003200020002000205
015+  C698             	DB   0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2
015+  C698 0002000200020002000200020002000200020002000200020002000200020002
016+  C6B8             	DB   2,  0,  2, 51,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2, 51,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0
016+  C6B8 0200023302000200020002000200020002000200023302000200020002000200
017+  C6D8             	DB   0,  1,  0,  1,  0,  1, 50,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1, 50,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1
017+  C6D8 0001000100013201000100010001000100013201000100010001000100010001
018+  C6F8             	DB   1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1, 50,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0, 50,  0,  1,  0,  1,  0,  1,  0
018+  C6F8 0100010001000100010001320100010001000100010001003200010001000100
019+  C718             	DB   0,  1,  0,  1, 49,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1
019+  C718 0001000131010001000100010001000100010001000100010001000100010001
020+  C738             	DB   1,  0,  1,  0, 48,  0,  1,  0,  1,  0,  1,  0,  1, 51,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0, 49,  0,  1,  0,  1,  0
020+  C738 0100010030000100010001000133010001000100010001000100310001000100
021+  C758             	DB   0,  1,  0,  1,  0,  1,  0,  1,  0, 49,  0,  1,  0,  1,  0,  1,  0,  1, 49,  1,  0,  1,  0,  1,  0,  1, 48,  1,  0,  1,  0,  1
021+  C758 0001000100010001003100010001000100013101000100010001300100010001
022+  C778             	DB   1, 51,  1,  0,  1,  0,  1,  0,  1, 48,  1,  0,  1,  0,  1,  0,  1,  0, 48,  0,  1,  0, 51,  0,  1,  0,  1,  0,  1,  0,  1,  0
022+  C778 0133010001000100013001000100010001003000010033000100010001000100
023+  C798             	DB   0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0, 51,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1
023+  C798 0001000100010001000100010033000100010001000100010001000100010001
024+  C7B8             	DB   1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0
024+  C7B8 0100010001000100010001000100010001000100010001000100010001000100
025+  C7D8             	;DB   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
026+  C7D8             	;DB   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
027+  C7D8             
028+  C7D8             
184   C7D8             map_screen1: 
185   C7D8             	include "src/map-screen1.asm"
001+  C7D8             
src/map-screen1.asm(2): warning: Label has different value in pass 3: 51160 != 50456
002+  C7D8             SCREEN_0_0: 
003+  C7D8             	DB  34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34
003+  C7D8 2222222222222222222222222222222222222222222222222222222222222222
004+  C7F8             	DB  34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34
004+  C7F8 2222222222222222222222222222222222222222222222222222222222222222
005+  C818             	DB  34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 11, 11, 34, 11, 11, 34, 11, 11, 34, 11, 11, 34, 11, 11, 34, 34
005+  C818 222222222222222222222222222222220B0B220B0B220B0B220B0B220B0B2222
006+  C838             	DB  34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 11, 11, 34, 11, 11, 34, 11, 11, 34, 11, 11, 34, 11, 11, 34, 34
006+  C838 222222222222222222222222222222220B0B220B0B220B0B220B0B220B0B2222
007+  C858             	DB  34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34
007+  C858 2222222222222222222222222222222222222222222222222222222222222222
008+  C878             	DB  34, 34, 34,  0,  0, 34, 34, 34, 34, 34, 34,  0,  0, 34, 34, 34, 11, 11, 34, 11, 11, 34, 11, 11, 34, 11, 11, 34, 11, 11, 34, 34
008+  C878 222222000022222222222200002222220B0B220B0B220B0B220B0B220B0B2222
009+  C898             	DB  34, 34, 34,  0,  0, 34, 34, 34, 34, 34, 34,  0,  0, 34, 34, 34, 11, 11, 34, 11, 11, 34, 11, 11, 34, 11, 11, 34, 11, 11, 34, 34
009+  C898 222222000022222222222200002222220B0B220B0B220B0B220B0B220B0B2222
010+  C8B8             	DB  34, 34, 34,  0,  0, 34, 34, 34, 34, 34, 34,  0,  0, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34
010+  C8B8 2222220000222222222222000022222222222222222222222222222222222222
011+  C8D8             	DB   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
011+  C8D8 0000000000000000000000000000000000000000000000000000000000000000
012+  C8F8             	DB   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
012+  C8F8 0000000000000000000000000000000000000000000000000000000000000000
013+  C918             	DB   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
013+  C918 0000000000000000000000000000000000000000000000000000000000000000
014+  C938             	DB   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
014+  C938 0000000000000000000000000000000000000000000000000000000000000000
015+  C958             	DB   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
015+  C958 0000000000000000000000000000000000000000000000000000000000000000
016+  C978             	DB   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
016+  C978 0000000000000000000000000000000000000000000000000000000000000000
017+  C998             	DB   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
017+  C998 0000000000000000000000000000000000000000000000000000000000000000
018+  C9B8             	DB   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
018+  C9B8 0000000000000000000000000000000000000000000000000000000000000000
019+  C9D8             	DB   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
019+  C9D8 0000000000000000000000000000000000000000000000000000000000000000
020+  C9F8             	DB   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
020+  C9F8 0000000000000000000000000000000000000000000000000000000000000000
021+  CA18             	DB   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
021+  CA18 0000000000000000000000000000000000000000000000000000000000000000
022+  CA38             	DB   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
022+  CA38 0000000000000000000000000000000000000000000000000000000000000000
023+  CA58             	DB   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
023+  CA58 0000000000000000000000000000000000000000000000000000000000000000
024+  CA78             	DB   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
024+  CA78 0000000000000000000000000000000000000000000000000000000000000000
025+  CA98             	;DB   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
026+  CA98             	;DB   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
027+  CA98             
028+  CA98             
186   CA98              
187   CA98             FINAL: 
